package w2;

import static org.junit.jupiter.api.Assertions.*;

import a2.AudioEngine;
import a2.AudioHandle;
import annotations.Audio;
import app.di.AppModule;
import com.google.inject.Guice;
import com.google.inject.Injector;
import java.awt.Image;
import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * Integration test for the viewport renderer using real FMOD engine and sample.wav.
 *
 * <p>Renders a 1000x400 viewport and asserts a warmed render completes in under 25 ms.
 */
@Audio
class WaveformRendererTest {

    private static final String SAMPLE_WAV = "packaging/samples/sample.wav";

    private Injector injector;
    private AudioEngine engine;
    private Waveform waveform;

    @BeforeEach
    void setUp() {
        // Build real AudioEngine via Guice (AppModule wires FMOD stack)
        injector = Guice.createInjector(new AppModule());
        engine = injector.getInstance(AudioEngine.class);
    }

    @AfterEach
    void tearDown() {
        if (waveform != null) {
            waveform.shutdown();
        }
        if (engine != null) {
            engine.close();
        }
    }

    @Test
    @DisplayName("Warm + render 1000x400 under 25 ms")
    void renderViewportUnder25ms() throws Exception {
        // Load audio and create waveform
        AudioHandle handle = engine.loadAudio(SAMPLE_WAV);
        waveform = new Waveform(SAMPLE_WAV, engine, handle);

        // Viewport: 5s span at 200 px/sec, 1000x250 (matching actual app)
        ViewportContext viewport =
                new ViewportContext(
                        0.0, 5.0, 1000, 250, 200, ViewportContext.ScrollDirection.FORWARD);

        // Warm up to populate caches and FMOD paths (not timed)
        Image warm = waveform.renderViewport(viewport).get(10, TimeUnit.SECONDS);
        assertNotNull(warm);

        // Measure a second render of the same viewport (should be cache-hit fast)
        long startNs = System.nanoTime();
        Image img = waveform.renderViewport(viewport).get(2, TimeUnit.SECONDS);
        long elapsedMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);

        assertNotNull(img);
        assertTrue(elapsedMs < 25, "Expected <25 ms, took " + elapsedMs + " ms");
    }
    
    @Test
    @DisplayName("Initial render completes within 1 second")
    void initialRenderUnder1Second() throws Exception {
        // Load audio and create waveform
        AudioHandle handle = engine.loadAudio(SAMPLE_WAV);
        waveform = new Waveform(SAMPLE_WAV, engine, handle);

        // Viewport matching actual app usage
        ViewportContext viewport =
                new ViewportContext(
                        0.0, 5.0, 1000, 250, 200, ViewportContext.ScrollDirection.FORWARD);

        // Measure initial render (should complete in reasonable time)
        long startNs = System.nanoTime();
        Image img = waveform.renderViewport(viewport).get(1, TimeUnit.SECONDS);
        long elapsedMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);

        assertNotNull(img, "Initial render should complete within 1 second");
        System.out.println("Initial render took " + elapsedMs + " ms");
    }
}
