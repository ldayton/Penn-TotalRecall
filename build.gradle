plugins {
    id 'java'
    id 'application'
    id 'distribution'
    id 'com.diffplug.spotless' version '7.2.+'
    id 'com.github.ben-manes.versions' version '0.52.+'
    id 'org.jetbrains.qodana' version '2025.2.1'
    id 'checkstyle'
}

group = 'edu.upenn.psych.memory'

def appProps = loadAppProperties()
version = appProps.getProperty('app.version')

ext {
    javaVersion = JavaVersion.VERSION_24
    programProperName = appProps.getProperty('app.name')
    programExtensionlessFilename = 'PennTotalRecall'
    maintainerName = 'Lily Dayton'
    maintainerEmail = 'lily.dayton.3@gmail.com'
    orgName = 'Computational Memory Lab, UPenn'
    uniqueIdentifier = 'edu.upenn.psych.memory.penntotalrecall'
    nativeAccessJvmArgs = [
        '--enable-native-access=ALL-UNNAMED',
        '-Dsun.java2d.uiScale.enabled=true',
        '-Dswing.aatext=true', 
        '-Dawt.useSystemAAFontSettings=on'
    ]
    isCI = System.getenv('CI') == 'true'

    flatlafVersion = '3.6.+'
    jacksonXmlVersion = '2.20.+'
    maryttsSignalprocVersion = '5.2.+'
    slf4jVersion = '2.0.+'
    logbackVersion = '1.5.+'
    guiceVersion = '7.0.+'
    caffeineVersion = '3.2.+'
    lombokVersion = '1.18.+'
    junitJupiterVersion = '5.10.+'
    mockitoVersion = '5.19.+'
    imageComparisonVersion = '4.4.+'
    junitPlatformLauncherVersion = '1.10.+'
    googleJavaFormatVersion = '1.22.0'
}

java {
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
}

application {
    mainClass = 'app.swing.Main'
    applicationDefaultJvmArgs = nativeAccessJvmArgs
}

repositories {
    mavenCentral()
}

dependencies {
    implementation "com.fasterxml.jackson.dataformat:jackson-dataformat-xml:${jacksonXmlVersion}"
    implementation("de.dfki.mary:marytts-signalproc:${maryttsSignalprocVersion}") {
        exclude group: 'gov.nist.math', module: 'Jampack'
        exclude group: 'com.twmacinta', module: 'fast-md5'
    }
    implementation "com.formdev:flatlaf:${flatlafVersion}:no-natives"
    implementation "com.formdev:flatlaf:${flatlafVersion}:linux-x86_64@so"
    implementation "com.formdev:flatlaf:${flatlafVersion}:macos-arm64@dylib"
    implementation "com.formdev:flatlaf:${flatlafVersion}:macos-x86_64@dylib"
    implementation "com.formdev:flatlaf:${flatlafVersion}:windows-x86_64@dll"
    implementation "org.slf4j:slf4j-api:${slf4jVersion}"
    implementation "ch.qos.logback:logback-classic:${logbackVersion}"
    implementation "com.google.inject:guice:${guiceVersion}"
    implementation "com.github.ben-manes.caffeine:caffeine:${caffeineVersion}"
    
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    compileOnly "com.google.errorprone:error_prone_annotations:2.26.+"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    testImplementation "org.junit.jupiter:junit-jupiter:${junitJupiterVersion}"
    testImplementation "org.mockito:mockito-core:${mockitoVersion}"
    testImplementation "org.mockito:mockito-junit-jupiter:${mockitoVersion}"
    testImplementation "com.github.romankh3:image-comparison:${imageComparisonVersion}"
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testCompileOnly "com.google.errorprone:error_prone_annotations:2.26.+"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher:${junitPlatformLauncherVersion}"
    
}

jar {
    archiveFileName = "${programExtensionlessFilename}.jar"
    manifest {
        attributes(
            'Main-Class': application.mainClass.get(),
            'Class-Path': '.',
            'Built-By': System.getProperty('user.name'),
            'Implementation-Vendor': orgName,
            'Implementation-Title': programProperName,
            'Implementation-Version': version
        )
    }
    
    from {
        configurations.runtimeClasspath
            .filter { it.isDirectory() || it.name.endsWith('.jar') }
            .collect { it.isDirectory() ? it : zipTree(it) }
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

clean {
    delete 'classes', 'dist'
}

tasks.register('createCustomRuntime') {
    group = 'packaging'
    description = 'Create minimal Java runtime using jlink'
    def customRuntimeDirProvider = layout.buildDirectory.dir("custom-runtime")
    doLast {
        def customRuntimeDir = customRuntimeDirProvider.get().asFile
        if (customRuntimeDir.exists()) {
            customRuntimeDir.deleteDir()
        }
        providers.exec {
            commandLine('jlink',
                '--add-modules', 'java.base,java.desktop,java.prefs,java.net.http,java.naming',
                '--strip-debug',
                '--no-man-pages',
                '--no-header-files',
                '--compress=2',
                '--output', customRuntimeDir.absolutePath)
        }.result.get()
        println "Custom runtime created at ${customRuntimeDir}"
    }
}

tasks.register('packageMacApp') {
    group = 'packaging'
    description = 'Create Mac .app bundle using jpackage'
    dependsOn jar, createCustomRuntime
    def appDirProvider = layout.buildDirectory.dir("packaging/mac")
    def customRuntimeDirProvider = layout.buildDirectory.dir("custom-runtime")
    doLast {
        def jarFile = jar.archiveFile.get().asFile
        def appDir = appDirProvider.get().asFile
        def appBundle = new File(appDir, "${programProperName}.app")
        if (appBundle.exists()) {
            appBundle.deleteDir()
        }
        appDir.mkdirs()
        def inputDir = layout.buildDirectory.dir("jpackage-input").get().asFile
        inputDir.mkdirs()
        copy {
            from jarFile
            into inputDir
        }
        providers.exec {
            commandLine('jpackage',
                '--input', inputDir,
                '--main-jar', jarFile.name,
                '--main-class', application.mainClass.get(),
                '--name', programProperName,
                '--app-version', version,
                '--description', 'Audio annotation tool for research',
                '--vendor', orgName,
                '--mac-package-identifier', uniqueIdentifier,
                '--icon', 'packaging/macos/headphones.icns',
                '--dest', appDir,
                '--type', 'app-image',
                '--runtime-image', customRuntimeDirProvider.get().asFile.absolutePath,
                '--java-options', nativeAccessJvmArgs.join(' '))
        }.result.get()
        def createdAppBundle = file("${appDir}/${programProperName}.app")
        def frameworksDir = file("${createdAppBundle}/Contents/Frameworks")
        frameworksDir.mkdirs()
        copy {
            from 'src/main/resources/fmod/macos/'
            into frameworksDir
            include '*.dylib'
        }
        def flatlafArm = configurations.runtimeClasspath
            .filter { it.name.endsWith('.dylib') && it.name.contains('flatlaf') && it.name.contains('macos-arm64') }
        def flatlafX64 = configurations.runtimeClasspath
            .filter { it.name.endsWith('.dylib') && it.name.contains('flatlaf') && it.name.contains('macos-x86_64') }
        if (flatlafArm.isEmpty() || flatlafX64.isEmpty()) {
            throw new GradleException("FlatLaf macOS native libraries not found on runtimeClasspath (require both arm64 and x86_64)")
        }
        copy {
            from(flatlafArm + flatlafX64)
            into frameworksDir
        }
        println "Mac .app created in ${appDir}"
    }
}

tasks.register('packageMacDmg') {
    group = 'packaging'
    description = 'Create Mac .dmg installer from existing .app bundle'
    dependsOn packageMacApp
    def dmgDirProvider = layout.buildDirectory.dir("packaging/mac")
    doLast {
        def dmgDir = dmgDirProvider.get().asFile
        def appBundle = new File(dmgDir, "${programProperName}.app")
        if (!appBundle.exists()) {
            throw new GradleException("App bundle not found: ${appBundle.absolutePath}")
        }
        dmgDir.listFiles().findAll { it.name.endsWith('.dmg') }.each { it.delete() }
        providers.exec {
            commandLine('jpackage',
                '--app-image', appBundle.absolutePath,
                '--name', programProperName,
                '--app-version', version,
                '--description', 'Audio annotation tool for research',
                '--vendor', orgName,
                '--copyright', 'Copyright Â© 2024 University of Pennsylvania',
                '--mac-package-identifier', uniqueIdentifier,
                '--mac-package-name', programProperName,
                '--resource-dir', 'packaging/macos',
                '--dest', dmgDir,
                '--type', 'dmg',
                '--verbose')
        }.result.get()
        def generatedDmg = file("${dmgDir}/${programProperName}-${version}.dmg")
        if (generatedDmg.exists()) {
            def dmgSize = String.format("%.1f MB", generatedDmg.length() / (1024 * 1024))
            println "âœ… DMG created: ${generatedDmg.name} (${dmgSize})"
            println "ðŸ“¦ Packaged existing .app bundle: ${appBundle.name}"
            println "ðŸŽ Ready for distribution - no additional dependencies required"
            println "ðŸ“ Location: ${generatedDmg.absolutePath}"
        } else {
            throw new GradleException("DMG creation failed - file not found")
        }
    }
}

distributions {
    main {
        distributionBaseName = programExtensionlessFilename
        contents {
            from jar
            from 'packaging/samples'
        }
    }
}

def loadAppProperties() {
    def configFile = file("src/main/resources/application.properties")
    if (configFile.exists()) {
        def props = new Properties()
        configFile.withInputStream { props.load(it) }
        return props
    } else {
        throw new GradleException("Application properties file not found: ${configFile.path}")
    }
}

def loadEnvironmentConfig(task, String env) {
    def configFile = file("src/main/resources/${env}.properties")
    if (configFile.exists()) {
        def props = new Properties()
        configFile.withInputStream { props.load(it) }
        props.each { key, value ->
            task.systemProperty key, value
        }
        println "Loaded ${env} configuration: ${props.size()} properties"
    } else {
        println "Configuration file not found: ${configFile.path}"
    }
}

tasks.withType(Test).configureEach {
    systemProperty 'prefs.namespace', 
        "/edu/upenn/psych/memory/penntotalrecall/test/" + java.util.UUID.randomUUID().toString()
}

test {
    def isCI = project.ext.isCI
    maxParallelForks = Runtime.runtime.availableProcessors()
    forkEvery = 1
    jvmArgs = nativeAccessJvmArgs
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showStandardStreams = true
    }
    def configProps = new Properties()
    def devConfigFile = file("src/main/resources/development.properties")
    if (devConfigFile.exists()) {
        devConfigFile.withInputStream { configProps.load(it) }
    }
    if (isCI) {
        def ciConfigFile = file("src/main/resources/ci.properties")
        if (ciConfigFile.exists()) {
            ciConfigFile.withInputStream { configProps.load(it) }
        }
    }
    useJUnitPlatform {
        excludeTags 'packaging'
        if (isCI) {
            excludeTags 'windowing'
            excludeTags 'audio'
        }
        def osName = System.getProperty('os.name').toLowerCase()
        if (!osName.contains('mac')) excludeTags 'macos'
        if (project.hasProperty('excludeTags')) {
            excludeTags project.property('excludeTags').toString().split(',')
        }
    }
    loadEnvironmentConfig(test, 'development')
    if (isCI) {
        loadEnvironmentConfig(test, 'ci')
    }
    systemProperty 'test.suppress.fmod.format.errors', System.getProperty('test.suppress.fmod.format.errors', 'true')
    systemProperty 'test.disable.prefetch', System.getProperty('test.disable.prefetch', 'true')
    System.getProperties().each { k, v ->
        if (k instanceof String && k.startsWith('test.')) {
            systemProperty k, v
        }
    }
}

tasks.named('check') {
    dependsOn tasks.named('packageTest')
}

tasks.register('packageTest', Test.class) {
    group = 'verification'
    description = 'Run packaging integration tests that require built application artifacts'
    dependsOn packageMacApp, testClasses
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    outputs.upToDateWhen { false }
    def isCI = project.ext.isCI
    jvmArgs = nativeAccessJvmArgs
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showStandardStreams = true
    }
    def configProps = new Properties()
    def devConfigFile = file("src/main/resources/development.properties")
    if (devConfigFile.exists()) {
        devConfigFile.withInputStream { configProps.load(it) }
    }
    if (isCI) {
        def ciConfigFile = file("src/main/resources/ci.properties")
        if (ciConfigFile.exists()) {
            ciConfigFile.withInputStream { configProps.load(it) }
        }
    }
    useJUnitPlatform {
        includeTags 'packaging'
    }
    configProps.each { key, value ->
        systemProperty key, value
    }
    if (isCI) {
        loadEnvironmentConfig(packageTest, 'ci')
    }
}

tasks.register('checkJavaVersion') {
    def requiredJavaVersion = javaVersion
    doLast {
        def currentJavaVersion = JavaVersion.current()
        if (currentJavaVersion < requiredJavaVersion) {
            throw new GradleException("Java ${requiredJavaVersion} or higher is required. Current version: ${currentJavaVersion}")
        }
        println "Java version check passed: ${currentJavaVersion}"
    }
}

compileJava.dependsOn checkJavaVersion

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += ['-Xlint:none']
}

tasks.register('runDev', JavaExec) {
    group = 'application'
    description = 'Run application in development mode with unpackaged FMOD loading'
    classpath = sourceSets.main.runtimeClasspath
    mainClass = application.mainClass
    jvmArgs = nativeAccessJvmArgs
    loadEnvironmentConfig(runDev, 'development')
    systemProperty 'app.run.dev', 'true'
    systemProperty 'apple.awt.application.name', appProps.getProperty('app.name')
}

spotless {
    java {
        target 'src/**/*.java'
        targetExclude 'src/main/java/audio/fmod/panama/**'
        googleJavaFormat(googleJavaFormatVersion).aosp().reflowLongStrings()
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
}

// Checkstyle configuration - only check main sources, not test
checkstyle {
    toolVersion = '10.21.0'
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
    sourceSets = [sourceSets.main]
    showViolations = true
    maxWarnings = 0
    maxErrors = 0
}

tasks.withType(Checkstyle).configureEach {
    exclude '**/audio/fmod/panama/**'
    reports {
        xml.required = false
        html.required = true
        html.outputLocation = layout.buildDirectory.file("reports/checkstyle/${name}.html")
    }
}

tasks.register('jextractFmod', Exec) {
    group = 'codegen'
    description = 'Generate Java Panama bindings for FMOD using jextract'
    inputs.file('src/main/resources/fmod/macos/fmod.h')
    inputs.files(fileTree('src/main/resources/fmod/macos') { include '*.h' })
    outputs.dir('src/main/java/core/audio/fmod/panama')
    doFirst {
        def defaultJextract = "${System.getProperty('user.home')}/jextract-22/bin/jextract"
        def jextractPath = (project.findProperty('jextractBin')
                ?: System.getenv('JEXTRACT_BIN')
                ?: defaultJextract).toString()
        def bin = file(jextractPath)
        if (!bin.exists() || !bin.canExecute()) {
            throw new GradleException("jextract not found or not executable at: ${jextractPath}. Set -PjextractBin=... or env JEXTRACT_BIN.")
        }
        file('src/main/java').mkdirs()
        // Ensure libclang from Command Line Tools is visible on macOS
        environment 'DYLD_LIBRARY_PATH', [
            '/Library/Developer/CommandLineTools/usr/lib',
            System.getenv('DYLD_LIBRARY_PATH')
        ].findAll { it && it.trim() }.join(File.pathSeparator)

        commandLine jextractPath,
                '-t', 'core.audio.fmod.panama',
                '--header-class-name', 'FmodCore',
                '-I', 'src/main/resources/fmod/macos',
                '-l', 'fmod',
                '--output', file('src/main/java').absolutePath,
                'src/main/resources/fmod/macos/fmod.h'
    }
}
