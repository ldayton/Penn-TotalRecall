plugins {
    id 'java'
    id 'application'
    id 'distribution'
    id 'com.diffplug.spotless' version '7.2.+'
    id 'com.github.ben-manes.versions' version '0.52.+'  // Dependency update checker
    id 'org.jetbrains.qodana' version '2025.2.1'
}

group = 'edu.upenn.psych.memory'
version = '2025.08.15'

// Project configuration
ext {
    javaVersion = JavaVersion.VERSION_24
    programProperName = 'Penn TotalRecall'
    programExtensionlessFilename = 'PennTotalRecall'
    maintainerName = 'Lily Dayton'
    maintainerEmail = 'lily.dayton.3@gmail.com'
    orgName = 'Computational Memory Lab, UPenn'
    uniqueIdentifier = 'edu.upenn.psych.memory.penntotalrecall'
    nativeAccessJvmArgs = ['--enable-native-access=ALL-UNNAMED']
}

java {
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
}

application {
    mainClass = 'control.Main'
    applicationDefaultJvmArgs = nativeAccessJvmArgs
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'net.java.dev.jna:jna:5.17.+'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.16.+'
    implementation('de.dfki.mary:marytts-signalproc:5.2.+') {
        exclude group: 'gov.nist.math', module: 'Jampack'
        exclude group: 'com.twmacinta', module: 'fast-md5'
    }
    implementation 'com.formdev:flatlaf:3.5.+'
    implementation 'org.slf4j:slf4j-api:2.0.+'
    implementation 'ch.qos.logback:logback-classic:1.5.+'
    implementation 'com.google.inject:guice:7.0.+'
    
    compileOnly 'org.projectlombok:lombok:1.18.+'
    annotationProcessor 'org.projectlombok:lombok:1.18.+'
    
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.+'
    testImplementation 'org.mockito:mockito-core:5.14.+'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.14.+'
    testCompileOnly 'org.projectlombok:lombok:1.18.+'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.+'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.+'
    
}

// Using standard Gradle layout:
// src/main/java - main source
// src/main/resources - main resources  
// src/test/java - test source

// Configure JAR manifest
jar {
    archiveFileName = "${programExtensionlessFilename}.jar"
    manifest {
        attributes(
            'Main-Class': application.mainClass.get(),
            'Class-Path': '.',
            'Built-By': System.getProperty('user.name'),
            'Implementation-Vendor': orgName,
            'Implementation-Title': programProperName,
            'Implementation-Version': version
        )
    }
    
    // Include all dependencies in the JAR (fat JAR)
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Clean task
clean {
    delete 'classes', 'dist'
}

// Create minimal Java runtime with jlink
tasks.register('createCustomRuntime') {
    group = 'packaging'
    description = 'Create minimal Java runtime using jlink'
    
    def customRuntimeDirProvider = layout.buildDirectory.dir("custom-runtime")
    
    doLast {
        def customRuntimeDir = customRuntimeDirProvider.get().asFile
        
        // Delete existing runtime if it exists
        if (customRuntimeDir.exists()) {
            customRuntimeDir.deleteDir()
        }
        
        providers.exec {
            commandLine('jlink',
                '--add-modules', 'java.base,java.desktop,java.logging,java.management,java.naming,java.prefs,java.xml',
                '--strip-debug',
                '--no-man-pages',
                '--no-header-files',
                '--compress=2',
                '--output', customRuntimeDir.absolutePath)
        }.result.get()
        
        println "Custom runtime created at ${customRuntimeDir}"
    }
}

// MacOS-only packaging

tasks.register('packageMacApp') {
    group = 'packaging'
    description = 'Create Mac .app bundle using jpackage'
    dependsOn jar, createCustomRuntime
    
    def appDirProvider = layout.buildDirectory.dir("packaging/mac")
    def customRuntimeDirProvider = layout.buildDirectory.dir("custom-runtime")
    
    doLast {
        def jarFile = jar.archiveFile.get().asFile
        def appDir = appDirProvider.get().asFile
        
        // Clean existing app bundle
        def appBundle = new File(appDir, "${programProperName}.app")
        if (appBundle.exists()) {
            appBundle.deleteDir()
        }
        
        appDir.mkdirs()
        
        // Copy JAR to input directory  
        def inputDir = layout.buildDirectory.dir("jpackage-input").get().asFile
        inputDir.mkdirs()
        
        copy {
            from jarFile
            into inputDir
        }
        
        // Use jpackage
        providers.exec {
            commandLine('jpackage',
                '--input', inputDir,
                '--main-jar', jarFile.name,
                '--main-class', application.mainClass.get(),
                '--name', programProperName,
                '--app-version', version,
                '--description', 'Audio annotation tool for research',
                '--vendor', orgName,
                '--mac-package-identifier', uniqueIdentifier,
                '--icon', 'packaging/macos/headphones.icns',
                '--dest', appDir,
                '--type', 'app-image',
                '--runtime-image', customRuntimeDirProvider.get().asFile.absolutePath,
                '--java-options', nativeAccessJvmArgs.join(' '))
        }.result.get()
        
        // Copy FMOD libraries to the correct location in app bundle
        def createdAppBundle = file("${appDir}/${programProperName}.app")
        def frameworksDir = file("${createdAppBundle}/Contents/Frameworks")
        frameworksDir.mkdirs()
        copy {
            from 'src/main/resources/fmod/macos/'
            into frameworksDir
            include '*.dylib'
        }
        
        println "Mac .app created in ${appDir}"
    }
}

// DMG packaging - pure Gradle/Java approach  
tasks.register('packageMacDmg') {
    group = 'packaging'
    description = 'Create Mac .dmg installer from existing .app bundle'
    dependsOn packageMacApp  // Use the .app created by packageMacApp
    
    def dmgDirProvider = layout.buildDirectory.dir("packaging/mac")
    
    doLast {
        def dmgDir = dmgDirProvider.get().asFile
        def appBundle = new File(dmgDir, "${programProperName}.app")
        
        // Verify .app bundle exists
        if (!appBundle.exists()) {
            throw new GradleException("App bundle not found: ${appBundle.absolutePath}")
        }
        
        // Clean any existing DMG files
        dmgDir.listFiles().findAll { it.name.endsWith('.dmg') }.each { it.delete() }
        
        // Create DMG from existing .app bundle using jpackage
        providers.exec {
            commandLine('jpackage',
                '--app-image', appBundle.absolutePath,
                '--name', programProperName,
                '--app-version', version,
                '--description', 'Audio annotation tool for research',
                '--vendor', orgName,
                '--copyright', 'Copyright ¬© 2024 University of Pennsylvania',
                '--mac-package-identifier', uniqueIdentifier,
                '--mac-package-name', programProperName,
                '--resource-dir', 'packaging/macos',
                '--dest', dmgDir,
                '--type', 'dmg',
                '--verbose')
        }.result.get()
        
        def generatedDmg = file("${dmgDir}/${programProperName}-${version}.dmg")
        if (generatedDmg.exists()) {
            def dmgSize = String.format("%.1f MB", generatedDmg.length() / (1024 * 1024))
            println "‚úÖ DMG created: ${generatedDmg.name} (${dmgSize})"
            println "üì¶ Packaged existing .app bundle: ${appBundle.name}"
            println "üçé Ready for distribution - no additional dependencies required"
            println "üìç Location: ${generatedDmg.absolutePath}"
        } else {
            throw new GradleException("DMG creation failed - file not found")
        }
    }
}


// Distribution configuration
distributions {
    main {
        distributionBaseName = programExtensionlessFilename
        contents {
            from jar
            from 'packaging/samples'
        }
    }
}

// Helper function to load environment-specific config and apply to task
def loadEnvironmentConfig(task, String env) {
    def configFile = file("src/main/resources/${env}.properties")
    if (configFile.exists()) {
        def props = new Properties()
        configFile.withInputStream { props.load(it) }
        props.each { key, value ->
            task.systemProperty key, value
        }
        println "Loaded ${env} configuration: ${props.size()} properties"
    } else {
        println "Configuration file not found: ${configFile.path}"
    }
}

// Test configuration
test {
    // Detect CI environment
    def isCI = System.getenv('CI') == 'true' || 
               System.getenv('GITHUB_ACTIONS') == 'true' ||
               System.getenv('BUILDKITE') == 'true'
    
    // Enable native access for JNA and FlatLAF
    jvmArgs = nativeAccessJvmArgs
    
    // Enable detailed test output
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showStandardStreams = true
    }
    
    // Load configuration properties to determine test behavior
    def configProps = new Properties()
    
    // Always load development configuration as baseline
    def devConfigFile = file("src/main/resources/development.properties")
    if (devConfigFile.exists()) {
        devConfigFile.withInputStream { configProps.load(it) }
    }
    
    // In CI environments, override with CI-specific settings
    if (isCI) {
        def ciConfigFile = file("src/main/resources/ci.properties")
        if (ciConfigFile.exists()) {
            ciConfigFile.withInputStream { configProps.load(it) }
        }
    }
    
    useJUnitPlatform {
        // Use the loaded property to control audio test exclusion
        def audioHardwareAvailable = configProps.getProperty('audio.hardware.available')
        if (audioHardwareAvailable == 'false') {
            excludeTags 'audio-hardware'
        }
    }
    
    // Also apply these properties to the test task for runtime use
    loadEnvironmentConfig(test, 'development')
    if (isCI) {
        loadEnvironmentConfig(test, 'ci')
    }
}

// Integration test for packaged .app FMOD loading
tasks.register('testPackagedFmodLoading') {
    group = 'verification'
    description = 'Integration test: Build .app and verify FMOD loading works in packaged environment'
    dependsOn packageMacApp, testClasses
    
    def appBundleProvider = layout.buildDirectory.dir("packaging/mac/${programProperName}.app")
    
    doLast {
        def appBundle = appBundleProvider.get().asFile
        if (!appBundle.exists()) {
            throw new GradleException("App bundle not found: ${appBundle.absolutePath}")
        }
        
        // Verify FMOD library exists in .app bundle
        def fmodLib = file("${appBundle}/Contents/Frameworks/libfmod.dylib")
        if (!fmodLib.exists()) {
            throw new GradleException("FMOD library not found in app bundle: ${fmodLib.absolutePath}")
        }
        
        println "üß™ Running FMOD loading integration test in packaged .app..."
        println "üì¶ App bundle: ${appBundle.name}"
        println "üîó FMOD library: ${fmodLib.name}"
        
        // Execute the real app bundle with integration test mode
        def appExecutable = file("${appBundle}/Contents/MacOS/${programProperName}")
        
        try {
            def result = providers.exec {
                commandLine appExecutable.absolutePath, '--integration-test'
                timeout = Duration.ofSeconds(12) // Kill if it takes longer than 12 seconds (slightly more than Java timeout)
                ignoreExitValue = true
            }.result.get()
            
            if (result.exitValue == 0) {
                println "‚úÖ Integration test PASSED: FMOD loads correctly in packaged environment"
            } else {
                throw new GradleException("‚ùå Integration test FAILED: Exit code ${result.exitValue}")
            }
        } catch (Exception e) {
            throw new GradleException("‚ùå Integration test execution failed: ${e.message}", e)
        }
    }
}

// Version compatibility check
tasks.register('checkJavaVersion') {
    def requiredJavaVersion = javaVersion // Capture at configuration time
    doLast {
        def currentJavaVersion = JavaVersion.current()
        if (currentJavaVersion < requiredJavaVersion) {
            throw new GradleException("Java ${requiredJavaVersion} or higher is required. Current version: ${currentJavaVersion}")
        }
        println "Java version check passed: ${currentJavaVersion}"
    }
}

// Make version check run before compilation
compileJava.dependsOn checkJavaVersion

// Configure compiler to show all warnings and fail on warnings
tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += ['-Xlint:all', '-Xlint:-serial']
}

// Development task - run with FMOD in unpackaged mode
tasks.register('runDev', JavaExec) {
    group = 'application'
    description = 'Run application in development mode with unpackaged FMOD loading'
    classpath = sourceSets.main.runtimeClasspath
    mainClass = application.mainClass
    jvmArgs = nativeAccessJvmArgs
    
    // Load development configuration
    loadEnvironmentConfig(runDev, 'development')
}

// Spotless code formatting configuration
spotless {
    java {
        target 'src/**/*.java'
        googleJavaFormat('1.22.0').aosp().reflowLongStrings()
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
}